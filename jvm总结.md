# JVM入门总结

小知识点：

1. 对象在栈中分配内存，堆中存放具体的方法和属性；
2. 堆和方法区是线程共享的，Java栈、本地方法栈、pc计数器是线程私有的；
3. 线程私有内存区随着线程的产生和销毁，不需要考虑更多的内存回收问题，编译时确定内存大小



------

面试常见：

1. **请你谈谈JVM的理解？**

    答：JVM是Java Virtual Machine（Java虚拟机）的缩写，它是一个虚构出来的计算机，是通过在实际计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆、栈、寄存器等，还有相应的指令系统。Java语言的一个非常重要的特点就是与平台无关性，一次编译随处运行，而这种平台无关性JVM起着至关重要的作用。Java编译器将.java文件编译成.class字节码文件，再通过JVM将每一条指令翻译成不同平台的机器码就能实现跨平台运行。

2. **Java8虚拟机和之前的变化？**

3. **什么是OOM，什么是栈溢出StackOverFlowError？怎么分析？**

4. **JVM常用的调优参数有哪些？**

5. **内存快照如何抓取？怎么分析Dump文件？**

6. **谈谈类加载器的认识？**



--------------------------------------------------------------------------------------------------------------------------------------------------

------



- ### JVM体系结构

![image-20211023163652767](C:\Users\24216\AppData\Roaming\Typora\typora-user-images\image-20211023163652767.png)

​      

JVM分为五大区域：程序计数器、Java栈、本地方法栈、方法区、堆

- **程序计数器：**

  首先回顾下进程与线程的概念，**进程是资源分配的最小单位，线程是CPU调度的最小单位**；每个线程通过抢占的方法获得CPU执行权。现在给出以下场景：

  某一次，线程A获得CPU执行权，开始执行内部程序。但是程序还没有执行完CPU执行权就被线程B抢走了。后来经过抢占，线程A又获得CPU执行权，那么此时线程A又会从头开始执行吗？那么肯定不会。

  此时程序计数器就粉墨登场了，**它记录当前线程所执行的指令地址，**当线程重新获得执行权时，就直接从记录的位置开始执行，分支结构、循环结构、跳转、异常也都依赖程序计数器来完成。

  **小结：**

  1. 程序计数器是线程私有的，随着线程的产生和销毁，每一个线程都有一个程序计数器，线程安全的
  2. 唯一一块不存在OOM异常的区域
  3. 如果执行的是Java方法，则记录Java字节码地址；如果执行native方法，则计数器为空

- **Java栈（VM栈）：**

  1. 线程私有的，每一个线程都有一个独享的虚拟机栈，因此是线程安全的；
  2. 存放8大基本数据类型（int short byte char boolean long float double）以及对象的引用地址；
  3. 每一个方法在执行时都会在虚拟机栈中创建一个栈帧，方法执行完毕后该栈帧就会被销毁。方法栈帧是以先进后出的方式进出虚拟机栈；
  4. 每一个栈帧包括局部变量表、操作数栈、动态链接、方法出口以及额外的出口
     - ![image-20211023191116521](C:\Users\24216\AppData\Roaming\Typora\typora-user-images\image-20211023191116521.png)
  5. 如果线程请求栈的深度大于虚拟机允许的深度，则会抛出StackOverflowError（通常递归导致）
  6. -Xss参数可以设置虚拟机栈的大小
  7. JVM动态扩展时无法申请到足够的内存则抛出OutOfMemoryError

- **本地方法栈：**

  1. 本地方法栈其实可以和Java虚拟机栈进行对比理解，唯一不同的是**本地方法栈是Java程序在调用本地方法的时候创建栈帧的地方**。和JVM栈一样，这个区域也会抛出StackOverflowError和OutOfMemoryError。

- **方法区**

  1. 线程共享，线程不安全
  2. 可能发生OutOfMemoryError
  3. 方法区存储的是class文件加载进来的静态变量、类信息、常量池以及编译器编译后的代码
     - 方法区里存放着类的版本，字段，方法，接口和常量池。常量池里存储着字面量和符号引用。
       - 符号引用包括：1.类的全限定名，2.字段名和属性，3.方法名和属性。
  4. 常量池分为class文件常量池和运行时常量池。
     - class文件常量池存储的是当class文件被Java虚拟机加载进来后存放在方法区的一些字面量和符号引用，字面量包括字符串和基本类型的常量。
     - 运行时常量是当class文件被加载完成后，Java虚拟机会将class文件常量池里的内容转移到运行时常量池，在class文件常量池的符号引用有一部分会被变为直接引用，比如说类的静态方法或私有方法、实例构造方法、父类方法，因为这些方法不会被重写，所以在加载的时候可以将符号引用转变为直接引用，而其他的一些方法是在这个方法被第一次调用的时候才会将符号引用转变为直接引用。且运行时常量池里的内容是可以动态添加的，如String的intern()方法能将string值添加到String常量池中，但jdk1.8后String常量池放到堆中。
     - ![image-20211023192351320](C:\Users\24216\AppData\Roaming\Typora\typora-user-images\image-20211023192351320.png)

- 堆

  1. 存放对象实例和数组，即new出来的对象

  2. 由于创建了大量的对象，因此是垃圾回收的主要工作区域

  3. 线程共享不安全

  4. 能够发生OutOfMemoryError

  5. Java堆区分为新生代和老年代，新生代又可以进一步划分为**Eden区、Survivor 1区、Survivor 2区**。具体比例参数的话，可以看一下下面这张图。

  6.  所有新创建的对象都将会存储在新生代Yong Generation中。如果Young Generation的数据在一次或多次GC后存活下来，那么将被转移到OldGeneration。新的Object总是创建在Eden Space。

     ![image-20211023202543720](C:\Users\24216\AppData\Roaming\Typora\typora-user-images\image-20211023202543720.png)

  

  

  

  

  

  

  

  

  

  

  

  

